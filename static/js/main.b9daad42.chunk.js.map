{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Algorithms/Dijkstra.jsx","PathfindingVisualizer/Algorithms/Astar.jsx","PathfindingVisualizer/Algorithms/BreadthFirstSearch.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","id","className","Component","updateNeighbourNodes","node","grid","neighbours","push","length","filter","neighbour","isVisited","distance","previousNode","Dijkstra","startNode","endNode","visitedNode","unvisitedNode","allNode","i","j","getAllNode","sort","first","second","closestNode","shift","Infinity","sortingUnvisted","distanceFromEndNode","manhattanDistance","NodeA","rowA","colA","rowB","colB","Math","abs","Astar","getNeighbourNodes","stack","right","bottom","left","top","BreadthFirstSearch","console","log","currentNode","START_NODE_ROW","floor","window","innerHeight","START_NODE_COL","innerWidth","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisulizer","state","width","height","mouseIsPressed","draggingStartNode","draggingEndNode","makeGrid","setState","toggleWall","toggleStart","toggleEnd","algorithm","document","getElementById","innerHTML","finishNode","visitedNodeinOrder","alert","shortestPathList","shortestPath","index","setTimeout","animateShortest","Button","onClick","classList","toggle","animateAlgo","map","rowIDX","key","nodeIDX","handleMouseDown","handleMouseEnter","handleMouseLeave","handleMouseUp","current_row","createNode","unshift","App","TopHeader","dropDownValue","text","DropdownButton","size","title","Dropdown","Item","as","e","changeValue","target","textContent","location","reload","React","Footer","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"mVAoBiBA,G,yLAhBL,IAAD,EACyFC,KAAKC,MAAhGC,EADE,EACFA,IAAKC,EADH,EACGA,IAAKC,EADR,EACQA,SAAUC,EADlB,EACkBA,QAASC,EAD3B,EAC2BA,OAAQC,EADnC,EACmCA,YAAaC,EADhD,EACgDA,aAAcC,EAD9D,EAC8DA,aAAcC,EAD5E,EAC4EA,UACnF,OACE,yBACEC,GAAE,UAAKR,EAAL,YAAYD,GACdU,UAAWR,EAAU,cAAeC,EAAS,aAAcC,EAAQ,YAAa,OAChFC,YAAe,kBAAMA,EAAYJ,EAAKD,IACtCM,aAAgB,kBAAMA,EAAaL,EAAKD,IACxCO,aAAgB,kBAAMA,EAAaN,EAAKD,IACxCQ,UAAa,kBAAMA,EAAUP,EAAKD,U,GAVvBW,c,eCwCnB,SAASC,EAAqBC,EAAMC,GAAO,IAChCd,EAAYa,EAAZb,IAAKC,EAAOY,EAAPZ,IACRc,EAAa,GAGbd,EAAM,GAAGc,EAAWC,KAAKF,EAAKb,EAAI,GAAGD,IACrCC,EAAMa,EAAKG,OAAS,GAAGF,EAAWC,KAAKF,EAAKb,EAAI,GAAGD,IACnDA,EAAM,GAAGe,EAAWC,KAAKF,EAAKb,GAAKD,EAAI,IACvCA,EAAMc,EAAK,GAAGG,OAAS,GAAGF,EAAWC,KAAKF,EAAKb,GAAKD,EAAI,IAC5De,EAAaA,EAAWG,QAAO,SAAAC,GAAS,OAAKA,EAAUC,aATjB,oBAYdL,GAZc,IAYtC,2BAAoC,CAAC,IAA1BI,EAAyB,QAChCA,EAAUE,SAAWR,EAAKQ,SAAW,EACrCF,EAAUG,aAAeT,GAdS,+BAmB3BU,MA9Df,SAAkBT,EAAMU,EAAWC,GAE/B,IAAMC,EAAc,GACpBF,EAAUH,SAAW,EAKrB,IAHA,IAAMM,EA0BV,SAAoBb,GAEhB,IADA,IAAMc,EAAU,GACPC,EAAI,EAAGA,EAAIf,EAAKG,OAAQY,IAC7B,IAAK,IAAIC,EAAG,EAAGA,EAAIhB,EAAKe,GAAGZ,OAAQa,IAC/BF,EAAQZ,KAAKF,EAAKe,GAAGC,IAG7B,OAAOF,EAjCeG,CAAWjB,GAGxBa,EAAcV,QAAQ,CAE3BU,EAAcK,MAAK,SAACC,EAAOC,GAAR,OAAmBD,EAAMZ,SAAWa,EAAOb,YAE9D,IAAMc,EAAcR,EAAcS,QAElC,IAAID,EAAY/B,OAAhB,CAOA,GAJA+B,EAAYf,WAAY,EACxBM,EAAYV,KAAKmB,GAGbA,EAAYd,WAAagB,IAAU,OAAOX,EAE9C,GAAIS,IAAgBV,EAAS,OAAOC,EAGpCd,EAAqBuB,EAAarB,MCK1C,SAASwB,EAAgBX,GACrBA,EAAcK,MAAK,SAACC,EAAOC,GAAR,OACdD,EAAMZ,SAAWY,EAAMM,qBAAwBL,EAAOb,SAAWa,EAAOK,wBAgBjF,SAASC,EAAkBC,EAAOhB,GAAU,IAC5BiB,EAAmBD,EAAxBxC,IAAgB0C,EAAQF,EAAbzC,IACN4C,EAAmBnB,EAAxBxB,IAAgB4C,EAAQpB,EAAbzB,IAElByC,EAAMF,oBAAsBO,KAAKC,IAAIL,EAAKE,GAAQE,KAAKC,IAAIJ,EAAKE,GAIpE,SAASjC,EAAqBC,EAAMC,GAAO,IAChCd,EAAYa,EAAZb,IAAKC,EAAOY,EAAPZ,IACRc,EAAa,GAGbd,EAAM,GAAGc,EAAWC,KAAKF,EAAKb,EAAI,GAAGD,IACrCC,EAAMa,EAAKG,OAAS,GAAGF,EAAWC,KAAKF,EAAKb,EAAI,GAAGD,IACnDA,EAAM,GAAGe,EAAWC,KAAKF,EAAKb,GAAKD,EAAI,IACvCA,EAAMc,EAAK,GAAGG,OAAS,GAAGF,EAAWC,KAAKF,EAAKb,GAAKD,EAAI,IAC5De,EAAaA,EAAWG,QAAO,SAAAC,GAAS,OAAKA,EAAUC,aATjB,oBAYdL,GAZc,IAYtC,2BAAoC,CAAC,IAA1BI,EAAyB,QAChCA,EAAUE,SAAWR,EAAKQ,SAAW,EACrCF,EAAUG,aAAeT,GAdS,+BAkB3BmC,MA3Ef,SAAelC,EAAMU,EAAWC,GAE5B,IAAMC,EAAc,GACpBF,EAAUH,SAAW,EAKrB,IAHA,IAAMM,EAiCV,SAAoBb,EAAMW,GAEtB,IADA,IAAMG,EAAU,GACPC,EAAI,EAAGA,EAAIf,EAAKG,OAAQY,IAC7B,IAAK,IAAIC,EAAG,EAAGA,EAAIhB,EAAKe,GAAGZ,OAAQa,IAC/BU,EAAkB1B,EAAKe,GAAGC,GAAIL,GAC9BG,EAAQZ,KAAKF,EAAKe,GAAGC,IAG7B,OAAOF,EAzCeG,CAAWjB,EAAMW,GAG9BE,EAAcV,QAAQ,CAE3BqB,EAAgBX,GAEhB,IAAMQ,EAAcR,EAAcS,QAElC,IAAID,EAAY/B,OAAhB,CAOA,GAJA+B,EAAYf,WAAY,EACxBM,EAAYV,KAAKmB,GAGbA,EAAYd,WAAagB,IAAU,OAAOX,EAE9C,GAAIS,IAAgBV,EAAS,OAAOC,EAGpCd,EAAqBuB,EAAarB,MCH1C,SAASmC,EAAkBnC,EAAMjB,EAAMqD,GAAQ,IACpCjD,EAAYJ,EAAZI,IAAKD,EAAOH,EAAPG,IAGZ,GAAIA,EAAMc,EAAK,GAAGG,OAAO,EAAG,CACxB,IAAMkC,EAAQrC,EAAKb,GAAKD,EAAI,IACJ,IAApBmD,EAAM/B,YACN+B,EAAM7B,aAAezB,EACrBqD,EAAMlC,KAAKmC,GACXA,EAAM/B,WAAY,GAM1B,GAAInB,EAAMa,EAAKG,OAAO,EAAG,CACrB,IAAMmC,EAAStC,EAAKb,EAAI,GAAGD,IACF,IAArBoD,EAAOhC,YACPgC,EAAO9B,aAAezB,EACtBqD,EAAMlC,KAAKoC,GACXA,EAAOhC,WAAY,GAM3B,GAAIpB,EAAM,EAAG,CACT,IAAMqD,EAAOvC,EAAKb,GAAKD,EAAI,IACJ,IAAnBqD,EAAKjC,YACLiC,EAAK/B,aAAezB,EACpBqD,EAAMlC,KAAKqC,GACXA,EAAKjC,WAAY,GAMzB,GAAInB,EAAM,EAAG,CACT,IAAMqD,EAAMxC,EAAKb,EAAI,GAAGD,IACF,IAAlBsD,EAAIlC,YACJkC,EAAIhC,aAAezB,EACnBqD,EAAMlC,KAAKsC,GACXA,EAAIlC,WAAY,IAMbmC,MAvEf,SAA4BzC,EAAMU,EAAWC,GACzC,IAAMyB,EAAQ,GACdA,EAAMlC,KAAKQ,GACXA,EAAUJ,WAAY,EACtBoC,QAAQC,IAAIjC,GAGZ,IAFA,IAAME,EAAc,GAChBgC,EAAclC,EACT0B,EAAMjC,QAEX,KADAyC,EAAcR,EAAMd,SACJhC,OAAhB,CAEA,GADAsB,EAAYV,KAAK0C,GACbA,IAAgBjC,EAAS,OAAOC,EAGpCuB,EAAkBnC,EAAM4C,EAAaR,GAMzC,OADAxB,EAAYV,KAAK0C,GACVhC,GCRPiC,EAAiBb,KAAKc,MAAMd,KAAKc,MAAMC,OAAOC,YAAY,IAAI,GAC9DC,EAAgE,EAA/CjB,KAAKc,MAAMd,KAAKc,MAAMC,OAAOG,WAAW,IAAI,GAC7DC,EAAkBnB,KAAKc,MAAMd,KAAKc,MAAMC,OAAOC,YAAY,IAAI,GAC/DI,EAAiE,EAA/CpB,KAAKc,MAAMd,KAAKc,MAAMC,OAAOG,WAAW,IAAI,GAK5DG,E,kDACJ,aAAe,IAAD,8BACZ,gBACKC,MAAQ,CACXC,MAAOR,OAAOG,WACdM,OAAQT,OAAOC,YACfhD,KAAM,GACNyD,gBAAgB,EAChBC,mBAAmB,EACnBC,iBAAiB,GARP,E,gEAcZ,IAAM3D,EAAO4D,IACb5E,KAAK6E,SAAS,CAAE7D,W,sCAKFb,EAAKD,GACnB,OAAIC,IAAQ0D,GAAkB3D,IAAQ+D,GACpCjE,KAAK6E,SAAS,CAACH,mBAAmB,SAClC1E,KAAK6E,SAAS,CAACJ,gBAAgB,KAG7BtE,IAAQgE,GAAmBjE,IAAQkE,GACrCpE,KAAK6E,SAAS,CAACF,iBAAiB,SAChC3E,KAAK6E,SAAS,CAACJ,gBAAgB,MAIjCK,EAAW9E,KAAKsE,MAAMtD,KAAMb,EAAKD,QACjCF,KAAK6E,SAAS,CAACJ,gBAAgB,O,uCAKhBtE,EAAKD,GACpB,GAAKF,KAAKsE,MAAMG,eAAhB,CAEA,GAAIzE,KAAKsE,MAAMI,kBAQb,OAPAK,EAAY/E,KAAKsE,MAAMtD,KAAMb,EAAKD,GAClCF,KAAK6E,SAAS,CAACH,mBAAmB,IAClC1E,KAAK6E,SAAS,CAACJ,gBAAgB,IAG/BZ,EAAiB1D,OACjB8D,EAAiB/D,GAKnB,GAAIF,KAAKsE,MAAMK,gBAQb,OAPAK,EAAUhF,KAAKsE,MAAMtD,KAAMb,EAAKD,GAChCF,KAAK6E,SAAS,CAACF,iBAAiB,IAChC3E,KAAK6E,SAAS,CAACJ,gBAAgB,IAG/BN,EAAkBhE,OAClBiE,EAAkBlE,GAIpB4E,EAAW9E,KAAKsE,MAAMtD,KAAMb,EAAKD,GACjCF,KAAK6E,SAAS,CAACJ,gBAAgB,O,uCAIhBtE,EAAKD,GACfF,KAAKsE,MAAMG,iBACZzE,KAAKsE,MAAMI,mBACbK,EAAY/E,KAAKsE,MAAMtD,KAAMb,EAAKD,GAGhCF,KAAKsE,MAAMK,iBACbK,EAAUhF,KAAKsE,MAAMtD,KAAMb,EAAKD,GAGlCF,KAAK6E,SAAS,CAACJ,gBAAgB,O,oCAInBtE,EAAKD,GACjBF,KAAK6E,SAAS,CAACH,mBAAmB,IAClC1E,KAAK6E,SAAS,CAACF,iBAAiB,IAChC3E,KAAK6E,SAAS,CAACJ,gBAAgB,M,oCAIlB,IAAD,OACRQ,EAAYC,SAASC,eAAe,yBAAyBC,UACjE1B,QAAQC,IAAIsB,GAFA,IAGLjE,EAAQhB,KAAKsE,MAAbtD,KACDU,EAAYV,EAAK6C,GAAgBI,GACjCoB,EAAarE,EAAKmD,GAAiBC,GACrCkB,EAAqB,GAEzB,OAAQL,GACN,IAAK,WACHK,EAAqB7D,EAAST,EAAMU,EAAW2D,GAC/C,MACF,IAAK,YACHC,EAAqBpC,EAAMlC,EAAMU,EAAW2D,GAC5C,MACF,IAAK,uBACHC,EAAqB7B,EAAmBzC,EAAMU,EAAW2D,GACzD,MACF,QACEE,MAAM,iCAUV,IALA,IAAMC,EAAmBC,EAAaJ,GAxB1B,WA6BHK,GACP,GAAIA,IAAUJ,EAAmBnE,OAAO,EAItC,OAHAwE,YAAW,WACT,EAAKC,gBAAgBJ,KACd,EAANE,GACG,CAAN,UAEFC,YAAW,WACT,IAAM/B,EAAc0B,EAAmBI,GACvCR,SAASC,eAAT,UAA2BvB,EAAYzD,IAAvC,YAA8CyD,EAAY1D,MAAOU,UAAU,mBACzE,EAAE8E,IAVCA,EAAQ,EAAGA,GAASJ,EAAmBnE,OAAO,EAAGuE,IAAS,CAAC,IAAD,IAA1DA,GAA0D,qC,sCAgBrDF,GAEd,IAFiC,IAAD,WAEvBE,GACPC,YAAW,WACT,IAAM/B,EAAc4B,EAAiBE,GACrCR,SAASC,eAAT,UAA2BvB,EAAYzD,IAAvC,YAA8CyD,EAAY1D,MAAOU,UAAU,uBAC1E,GAAG8E,IAJCA,EAAQ,EAAGA,EAAQF,EAAiBrE,OAAO,EAAGuE,IAAU,EAAxDA,K,+BAYD,IAAD,SAC0B1F,KAAKsE,MAA9BtD,EADD,EACCA,KAAMyD,EADP,EACOA,eACd,OACE,6BACE,yBAAK7D,UAAU,aAAaD,GAAG,cAC7B,kBAACkF,EAAA,EAAD,CAAQlF,GAAG,gBAAgBmF,QAAS,WAClCZ,SAASC,eAAe,iBAAiBY,UAAUC,OAAO,eAC1Dd,SAASC,eAAe,cAAcY,UAAUC,OAAO,eACvD,EAAKC,gBAHP,eAMF,yBAAKrF,UAAU,QACZI,EAAKkF,KAAI,SAAC/F,EAAKgG,GAAN,OAEN,yBAAKC,IAAKD,EAAQvF,UAAU,OAEzBT,EAAI+F,KAAI,SAACnF,EAAMsF,GAAa,IACtBlG,EAAuCY,EAAvCZ,IAAKD,EAAkCa,EAAlCb,IAAKE,EAA6BW,EAA7BX,SAAUC,EAAmBU,EAAnBV,QAASC,EAAUS,EAAVT,OAGlC,OAAQ,kBAAC,EAAD,CACN8F,IAAKC,EACLnG,IAAOA,EACPC,IAAOA,EACPE,QAAWA,EACXD,SAAYA,EACZE,OAAUA,EACVmE,eAAkBA,EAClBlE,YAAa,SAACJ,EAAKD,GAAN,OAAc,EAAKoG,gBAAgBnG,EAAKD,IACrDM,aAAc,SAACL,EAAKD,GAAN,OAAc,EAAKqG,iBAAiBpG,EAAKD,IACvDO,aAAc,SAACN,EAAKD,GAAN,OAAc,EAAKsG,iBAAiBrG,EAAKD,IACvDQ,UAAW,kBAAM,EAAK+F,gC,GArLP5F,aAoM7BkE,EAAc,SAAC/D,EAAMb,EAAKD,GAC9B,IAAMa,EAAOC,EAAKb,GAAKD,GAGvB,OAFAa,EAAKV,SAAWU,EAAKV,QACrBW,EAAKb,GAAKD,GAAOa,EACVC,GAGHgE,EAAY,SAAChE,EAAMb,EAAKD,GAC5B,IAAMa,EAAOC,EAAKb,GAAKD,GAGvB,OAFAa,EAAKX,UAAYW,EAAKX,SACtBY,EAAKb,GAAKD,GAAOa,EACVC,GAGH8D,EAAa,SAAC9D,EAAMb,EAAKD,GAC7B,IAAMa,EAAOC,EAAKb,GAAKD,GAGvB,OAFAa,EAAKT,QAAUS,EAAKT,OACpBU,EAAKb,GAAKD,GAAOa,EACVC,GAIH4D,EAAW,WAEf,IADA,IAAM5D,EAAO,GACJb,EAAM,EAAGA,EAAM4D,OAAOC,YAAY,GAAG,EAAG7D,IAAO,CAEtD,IADA,IAAMuG,EAAc,GACXxG,EAAM,EAAGA,EAAM6D,OAAOG,WAAW,GAAIhE,IAC5CwG,EAAYxF,KAAKyF,EAAWzG,EAAKC,IAEnCa,EAAKE,KAAKwF,GAEZ,OAAO1F,GAMH2F,EAAa,SAACzG,EAAKC,GACvB,MAAO,CACLD,MACAC,MACAG,QAAQ,EAERD,QAASF,IAAQ0D,GAAkB3D,IAAQ+D,EAC3C7D,SAAUD,IAAQgE,GAAmBjE,IAAQkE,EAG7C7C,SAAUgB,IACVE,oBAAqB,EACrBnB,WAAW,EACXE,aAAc,OAMZiE,EAAe,SAACJ,GAGpB,IAFA,IAAMG,EAAmB,GACrB5B,EAAcyB,EACK,OAAhBzB,GACL4B,EAAiBoB,QAAQhD,GACzBA,EAAcA,EAAYpC,aAE5B,OAAOgE,GAKMnB,I,eCrRTwC,E,uKAEF,OACE,6BACE,kBAAC,EAAD,MACA,kBAAC,EAAD,MACA,kBAAC,EAAD,W,GANUhG,aAYZiG,E,kDACJ,aAAe,IAAD,8BACZ,gBACKxC,MAAQ,CACXyC,cAAe,cAHL,E,wDAOFC,GACVhH,KAAK6E,SAAS,CAACkC,cAAeC,M,+BAGtB,IAAD,OACP,OACE,yBAAKrG,GAAG,eAEN,yBAAKC,UAAU,gBAAf,2BACA,wBAAIA,UAAU,WACZ,4BACE,kBAACqG,EAAA,EAAD,CAAgBC,KAAK,KAAIvG,GAAG,wBAAwBwG,MAAOnH,KAAKsE,MAAMyC,eACpE,kBAACK,EAAA,EAASC,KAAV,CAAeC,GAAG,UAChB,yBAAKxB,QAAS,SAACyB,GAAD,OAAO,EAAKC,YAAYD,EAAEE,OAAOC,eAA/C,aAEF,kBAACN,EAAA,EAASC,KAAV,CAAeC,GAAG,UAClB,yBAAKxB,QAAS,SAACyB,GAAD,OAAO,EAAKC,YAAYD,EAAEE,OAAOC,eAA/C,cAEA,kBAACN,EAAA,EAASC,KAAV,CAAeC,GAAG,UAClB,yBAAKxB,QAAS,SAACyB,GAAD,OAAO,EAAKC,YAAYD,EAAEE,OAAOC,eAA/C,yBAEA,kBAACN,EAAA,EAASC,KAAV,CAAeC,GAAG,UAClB,yBAAKxB,QAAS,SAACyB,GAAD,OAAO,EAAKC,YAAYD,EAAEE,OAAOC,eAA/C,6BAEA,kBAACN,EAAA,EAASC,KAAV,CAAeC,GAAG,UAClB,yBAAKxB,QAAS,SAACyB,GAAD,OAAO,EAAKC,YAAYD,EAAEE,OAAOC,eAA/C,yBAIJ,wBAAI9G,UAAU,eACZ,kBAACiF,EAAA,EAAD,CAAQlF,GAAG,WAAWmF,QAAS,WAAO/B,OAAO4D,SAASC,QAAO,KAA7D,gBAIF,wBAAIhH,UAAU,eACZ,kBAACiF,EAAA,EAAD,CAAQlF,GAAG,cAAX,kBAIF,wBAAIC,UAAU,eACZ,kBAACiF,EAAA,EAAD,CAAQlF,GAAG,iBAAX,mB,GAhDYkH,IAAMhH,WA0DxBiH,E,uKAEF,OACE,yBAAKnH,GAAG,cAAcC,UAAU,UAAhC,qB,GAHeiH,IAAMhH,WAYZgG,IC7EKkB,QACW,cAA7BhE,OAAO4D,SAASK,UAEe,UAA7BjE,OAAO4D,SAASK,UAEhBjE,OAAO4D,SAASK,SAASC,MACvB,2D,MCXNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFlD,SAASC,eAAe,SDwHpB,kBAAmBkD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLlF,QAAQkF,MAAMA,EAAMC,c","file":"static/js/main.b9daad42.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nclass Node extends Component {\n  render() {\n    let {col, row, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseLeave, onMouseUp} = this.props;\n    return (\n      <div \n        id={`${row},${col}`}\n        className={isFinish? \"node-finish\": isStart? \"node-start\": isWall? \"node-wall\": \"node\"}\n        onMouseDown = {() => onMouseDown(row, col)}\n        onMouseEnter = {() => onMouseEnter(row, col)}\n        onMouseLeave = {() => onMouseLeave(row, col)}\n        onMouseUp = {() => onMouseUp(row, col)}\n      ></div>\n      );\n    }\n  }\n  \n  \n  export default Node;\n  ","function Dijkstra(grid, startNode, endNode) {\n    // first we need an empty array for returning node in ordered\n    const visitedNode = [];\n    startNode.distance = 0;\n    // store all the unvisitedNode in an array\n    const unvisitedNode = getAllNode(grid);\n\n    // while loop when unvisitedNode is not empty\n    while (!!unvisitedNode.length) {\n        // sort the unvisitedNode\n        unvisitedNode.sort((first, second) => first.distance - second.distance);\n        // first we get the closest node to the last node\n        const closestNode = unvisitedNode.shift();\n\n        if (closestNode.isWall) continue;\n        \n        // add the closest node in visited node in ordered and mark isVisited\n        closestNode.isVisited = true;\n        visitedNode.push(closestNode);\n\n        // If it is trapped and the closest node is Infinity distance away\n        if (closestNode.distance === Infinity) return visitedNode;\n        // if the closest node = end node, return the visited node array\n        if (closestNode === endNode) return visitedNode ;\n        // find all the neigbours node to distance + 1\n        // and set the neigbouring node pointed back to closest node\n        updateNeighbourNodes(closestNode, grid);\n    }\n}\n\n\nfunction getAllNode(grid) {\n    const allNode = []\n    for (let i = 0; i < grid.length; i++) {\n        for (let j= 0; j < grid[i].length; j++) {\n            allNode.push(grid[i][j]);\n        }  \n    }\n    return allNode;\n}\n\n\n\nfunction updateNeighbourNodes(node, grid) {\n    const {col, row} = node;\n    let neighbours = [];\n\n    // get all unvisted neighbouring node\n    if (row > 0) neighbours.push(grid[row-1][col]);\n    if (row < grid.length - 1) neighbours.push(grid[row+1][col]);\n    if (col > 0) neighbours.push(grid[row][col-1]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n    neighbours = neighbours.filter(neighbour => !neighbour.isVisited);\n\n    // update the unvisited neigbours' nodes' distance and previousNode\n    for (const neighbour of neighbours) {\n        neighbour.distance = node.distance + 1;\n        neighbour.previousNode = node;\n    }    \n}\n\n\nexport default Dijkstra;","function Astar(grid, startNode, endNode) {\n    // first we need an empty array for returning node in ordered\n    const visitedNode = [];\n    startNode.distance = 0;\n    // store all the unvisitedNode in an array\n    const unvisitedNode = getAllNode(grid, endNode);\n\n    // while loop when unvisitedNode is not empty\n    while (!!unvisitedNode.length) {\n        // sort the unvisitedNode\n        sortingUnvisted(unvisitedNode);\n        // first we get the closest node to the last node\n        const closestNode = unvisitedNode.shift();\n\n        if (closestNode.isWall) continue;\n        \n        // add the closest node in visited node in ordered and mark isVisited\n        closestNode.isVisited = true;\n        visitedNode.push(closestNode);\n\n        // It processed all node on grid\n        if (closestNode.distance === Infinity) return visitedNode;\n        // if the closest node = end node, return the visited node array\n        if (closestNode === endNode) return visitedNode ;\n        // find all the neigbours node to distance + 1\n        // and set the neigbouring node pointed back to closest node\n        updateNeighbourNodes(closestNode, grid);\n    }\n\n}\n\nfunction sortingUnvisted(unvisitedNode) {\n    unvisitedNode.sort((first, second) => \n        (first.distance + first.distanceFromEndNode) - (second.distance + second.distanceFromEndNode)\n    )\n}\n\n\nfunction getAllNode(grid, endNode) {\n    const allNode = []\n    for (let i = 0; i < grid.length; i++) {\n        for (let j= 0; j < grid[i].length; j++) {\n            manhattanDistance(grid[i][j], endNode);\n            allNode.push(grid[i][j]);\n        }  \n    }\n    return allNode;\n}\n\nfunction manhattanDistance(NodeA, endNode) {\n    const {row: rowA, col: colA} = NodeA;\n    const {row: rowB, col: colB} = endNode;\n\n    NodeA.distanceFromEndNode = Math.abs(rowA-rowB) + Math.abs(colA-colB);\n    return;\n}\n\nfunction updateNeighbourNodes(node, grid) {\n    const {col, row} = node;\n    let neighbours = [];\n\n    // get all unvisted neighbouring node\n    if (row > 0) neighbours.push(grid[row-1][col]);\n    if (row < grid.length - 1) neighbours.push(grid[row+1][col]);\n    if (col > 0) neighbours.push(grid[row][col-1]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n    neighbours = neighbours.filter(neighbour => !neighbour.isVisited);\n\n    // update the unvisited neigbours' nodes' distance and previousNode\n    for (const neighbour of neighbours) {\n        neighbour.distance = node.distance + 1;\n        neighbour.previousNode = node;\n    }    \n}\n\nexport default Astar;","function BreadthFirstSearch(grid, startNode, endNode) {\n    const stack = [];\n    stack.push(startNode);\n    startNode.isVisited = true;\n    console.log(startNode);\n    const visitedNode = [];\n    let currentNode = startNode; // use \"let\" instead of const for use to fix the bug below and declare it in the while loop\n    while (!!stack.length) {\n        currentNode = stack.shift();\n        if (currentNode.isWall) continue;\n        visitedNode.push(currentNode);\n        if (currentNode === endNode) return visitedNode;\n        \n        // push neighbourNodes on the stack\n        getNeighbourNodes(grid, currentNode, stack);\n        \n    }\n    \n\n    visitedNode.push(currentNode); // fix a bug where the last node won't filled in when trapped\n    return visitedNode;\n}\n\nfunction getNeighbourNodes(grid, Node, stack) {\n    const {row, col} = Node;\n\n    // get right neightbours\n    if (col < grid[0].length-1) {\n        const right = grid[row][col+1];\n        if (right.isVisited === false) {\n            right.previousNode = Node;\n            stack.push(right);\n            right.isVisited = true;\n\n        }\n    }\n\n    // get bottom neighbours\n    if (row < grid.length-1) {\n        const bottom = grid[row+1][col];\n        if (bottom.isVisited === false) {\n            bottom.previousNode = Node;\n            stack.push(bottom);\n            bottom.isVisited = true;\n\n        }\n    }\n\n    // get left neightbours\n    if (col > 0) {\n        const left = grid[row][col-1];\n        if (left.isVisited === false) {\n            left.previousNode = Node;\n            stack.push(left);\n            left.isVisited = true;\n \n        }\n    }\n\n    // get top neighbours\n    if (row > 0) {\n        const top = grid[row-1][col];\n        if (top.isVisited === false) {\n            top.previousNode = Node;\n            stack.push(top);\n            top.isVisited = true;\n \n        }\n    }\n    \n}\nexport default BreadthFirstSearch;","import React, { Component } from \"react\";\nimport \"./PathfindingVisualizer.css\";\nimport Node from \"./Node/Node\";\n\nimport Button from 'react-bootstrap/Button'\n\nimport Dijkstra from \"./Algorithms/Dijkstra\"\nimport Astar from \"./Algorithms/Astar\"\nimport BreadthFirstSearch from \"./Algorithms/BreadthFirstSearch\";\n\n\n// set the Default starting and end node\nlet START_NODE_ROW = Math.floor(Math.floor(window.innerHeight/25)/3);\nlet START_NODE_COL = Math.floor(Math.floor(window.innerWidth/25)/4)*1;\nlet FINISH_NODE_ROW = Math.floor(Math.floor(window.innerHeight/25)/3);\nlet FINISH_NODE_COL = Math.floor(Math.floor(window.innerWidth/25)/4)*3;\n\n\n\n// Defining a class for PathfindingVisulizer for App.js\nclass PathfindingVisulizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      grid: [],\n      mouseIsPressed: false,\n      draggingStartNode: false,\n      draggingEndNode: false\n    };\n  }\n\n  // It render initialy to greate a grid\n  componentDidMount() {\n    const grid = makeGrid();\n    this.setState({ grid });\n  }\n\n// ----------------------------------------------------------- Handling use interctive control ----------------------------------//\n  \n  handleMouseDown(row, col) {\n    if (row === START_NODE_ROW && col === START_NODE_COL){\n      this.setState({draggingStartNode: true});\n      this.setState({mouseIsPressed: true});\n      return;\n    }\n    if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL){\n      this.setState({draggingEndNode: true});\n      this.setState({mouseIsPressed: true});\n      return;\n    }\n    \n    toggleWall(this.state.grid, row, col);\n    this.setState({mouseIsPressed: true});\n  \n  }\n\n  // When mouse is pressed and entering a node\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n\n    if (this.state.draggingStartNode){\n      toggleStart(this.state.grid, row, col);\n      this.setState({draggingStartNode: true});\n      this.setState({mouseIsPressed: true});\n\n      // ----------\n      START_NODE_ROW = row;\n      START_NODE_COL = col;\n      return;\n      \n    }\n\n    if (this.state.draggingEndNode) {\n      toggleEnd(this.state.grid, row, col);\n      this.setState({draggingEndNode: true});\n      this.setState({mouseIsPressed: true});\n\n      // -------\n      FINISH_NODE_ROW = row;\n      FINISH_NODE_COL = col;\n      return;\n    }\n\n    toggleWall(this.state.grid, row, col);\n    this.setState({mouseIsPressed: true});\n    \n  }\n  // When mouse is presed and leaving a node\n  handleMouseLeave(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    if (this.state.draggingStartNode){\n      toggleStart(this.state.grid, row, col);\n    }\n\n    if (this.state.draggingEndNode) {\n      toggleEnd(this.state.grid, row, col);\n    }\n\n    this.setState({mouseIsPressed: true});\n  }\n  \n  // when releasing the mouse\n  handleMouseUp(row, col) {\n    this.setState({draggingStartNode: false});\n    this.setState({draggingEndNode: false});\n    this.setState({mouseIsPressed: false});\n  }\n// ---------------------------------------------------------------Animating Algorithms ------------------------------------------------------------// \n\n  animateAlgo() {\n    let algorithm = document.getElementById(\"dropdown-basic-button\").innerHTML\n    console.log(algorithm)\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL]\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    let visitedNodeinOrder = [];\n    // selecting algorithms\n    switch (algorithm) {\n      case \"Dijkstra\":\n        visitedNodeinOrder = Dijkstra(grid, startNode, finishNode);\n        break;\n      case \"A* Search\":\n        visitedNodeinOrder = Astar(grid, startNode, finishNode);\n        break;\n      case \"Breadth First search\":\n        visitedNodeinOrder = BreadthFirstSearch(grid, startNode, finishNode);\n        break;\n      default:\n        alert(\"Please select valid algorithm\");\n        break;\n    }\n\n    //const visitedNodeinOrder = Astar(grid, startNode, finishNode);\n    const shortestPathList = shortestPath(finishNode);\n\n    \n\n    // generating a shortestPath with starting node as the first index\n    for (let index = 1; index <= visitedNodeinOrder.length-1; index++) {\n      if (index === visitedNodeinOrder.length-1) {\n        setTimeout(() => {\n          this.animateShortest(shortestPathList);\n        }, index*3);\n        return;    \n      }\n      setTimeout(() => {\n        const currentNode = visitedNodeinOrder[index];\n        document.getElementById(`${currentNode.row},${currentNode.col}`).className=\"node-animation\"\n       }, 3*index);\n    }\n  }\n\n\n\n  animateShortest(shortestPathList) {\n    // generating a shortestPath with starting node as the first index\n    for (let index = 1; index < shortestPathList.length-1; index++) {\n      setTimeout(() => {\n        const currentNode = shortestPathList[index];\n        document.getElementById(`${currentNode.row},${currentNode.col}`).className=\"node-shortest-path\"\n      }, 20*index);\n    }\n  }\n\n  // ------------------------------------------------------------------Rendering entire grid constantly-----------------------------------------------------------------------------// \n            // Too much things rendering at the same time\n            // Suggestion: only render entire grid during animation stage, and render indiidual node otherwise\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    return (\n      <div>\n        <div className=\"visual-div\" id=\"visual-div\">\n          <Button id=\"visualize-btn\" onClick={() => {\n            document.getElementById(\"visualize-btn\").classList.toggle(\"changecolor\")\n            document.getElementById(\"visual-div\").classList.toggle(\"changecolor\")\n            this.animateAlgo()\n          }}>Visualize!</Button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIDX) => \n              // only returning one div object, hence return is omitted\n              <div key={rowIDX} className=\"row\">\n                {/* iterate through the matrix to display the node element */}\n                {row.map((node, nodeIDX) => {\n                  let {row, col, isFinish, isStart, isWall} = node;\n                  \n                  // passing in properties for creating a node object\n                  return (<Node\n                    key={nodeIDX}\n                    col = {col}\n                    row = {row}\n                    isStart = {isStart}\n                    isFinish = {isFinish}\n                    isWall = {isWall}\n                    mouseIsPressed = {mouseIsPressed}\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                    onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\n                    onMouseUp={() => this.handleMouseUp()}\n                     />);\n              })}\n              </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n/*----------------------------------------------------------------------------------------Helper Function ----------------------------------*/\n\n// Used when user drag their mouse to toggle Wall\nconst toggleStart = (grid, row, col) => {\n  const node = grid[row][col];\n  node.isStart = !node.isStart;\n  grid[row][col] = node;\n  return grid;\n}\n\nconst toggleEnd = (grid, row, col) => {\n  const node = grid[row][col];\n  node.isFinish = !node.isFinish;\n  grid[row][col] = node;\n  return grid;\n}\n\nconst toggleWall = (grid, row, col) => {\n  const node = grid[row][col];\n  node.isWall = !node.isWall;\n  grid[row][col] = node;\n  return grid;\n};\n\n// generating a matrix called grid (20X40) with node for each index\nconst makeGrid = () => {\n  const grid = [];\n  for (let row = 0; row < window.innerHeight/25-6; row++) {\n    const current_row = [];\n    for (let col = 0; col < window.innerWidth/25; col++) {\n      current_row.push(createNode(col, row));\n    }\n    grid.push(current_row);\n  }\n  return grid;\n};\n\n\n// This is the node we use for backend algorithms, the one in Node.jsx is for displaying on to the screen taking each node's properties\n// creating a Node with properties\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isWall: false,\n    // if the node row and col is the default start or end node\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n\n    // properties for algorithms\n    distance: Infinity,\n    distanceFromEndNode: 0,   // for Astar algorithm\n    isVisited: false,\n    previousNode: null,\n  };\n};\n\n\n// execute after animated the algorithms animation\nconst shortestPath = (finishNode) => {\n  const shortestPathList = [];\n  let currentNode = finishNode\n  while (currentNode !== null) {\n    shortestPathList.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return shortestPathList;\n}\n\n\n\nexport default PathfindingVisulizer;\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport DropdownButton from 'react-bootstrap/DropdownButton';\nimport Dropdown from 'react-bootstrap/Dropdown';\nimport Button from 'react-bootstrap/Button' \n\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <TopHeader/>\n        <PathfindingVisualizer></PathfindingVisualizer>\n        <Footer />\n      </div>\n    );\n  }\n}\n\nclass TopHeader extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      dropDownValue: \"Algorithms\"\n    }\n  }\n\n  changeValue(text) {\n    this.setState({dropDownValue: text})\n  }\n\n  render() {\n    return (\n      <div id=\"page-header\">\n        \n        <div className=\"title-header\">Path Finding Visualizer</div>\n        <ul className=\"nav-bar\">\n          <li>\n            <DropdownButton size=\"xl\"id=\"dropdown-basic-button\" title={this.state.dropDownValue}>\n              <Dropdown.Item as=\"button\">\n                <div onClick={(e) => this.changeValue(e.target.textContent)}>Dijkstra</div>\n              </Dropdown.Item>\n              <Dropdown.Item as=\"button\">\n              <div onClick={(e) => this.changeValue(e.target.textContent)}>A* Search</div>\n              </Dropdown.Item>\n              <Dropdown.Item as=\"button\">\n              <div onClick={(e) => this.changeValue(e.target.textContent)}>Breadth First search</div>\n              </Dropdown.Item>\n              <Dropdown.Item as=\"button\">\n              <div onClick={(e) => this.changeValue(e.target.textContent)}>Greedy Best First search</div>\n              </Dropdown.Item>\n              <Dropdown.Item as=\"button\">\n              <div onClick={(e) => this.changeValue(e.target.textContent)}>Depth First search</div>\n              </Dropdown.Item>\n            </DropdownButton>\n          </li>\n          <li className=\"nav-element\">\n            <Button id=\"stop-vis\" onClick={() => {window.location.reload(false)}}>\n              Clear Board\n            </Button>\n          </li>\n          <li className=\"nav-element\">\n            <Button id=\"weight-btn\">\n              Weighted node\n            </Button>\n          </li>\n          <li className=\"nav-element\">\n            <Button id=\"tuitorial-btn\">\n              Tutorial\n            </Button>\n          </li>\n        </ul>\n      </div>\n    );\n  }\n}\n\nclass Footer extends React.Component {\n  render() {\n    return (\n      <div id=\"page-footer\" className=\"footer\">\n        Version 1.1.1\n      </div>\n    );\n  }\n}\n\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}